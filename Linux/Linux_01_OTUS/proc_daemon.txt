***********************************************************
****************** Процессы в Linux ***********************
***********************************************************

****************** Жизненый цикл процесса *****************
В Linux процусс создается путем копирования уже существующего процесса (fork)
fork()
Системный вызов, создающий новый процесс
Создает полную копию процесса
Стартует в одном процесс, завершается в двух

exec()
Системный вызов, заменяющий исполняемый код в процессе
В качестве параметров принимает имя исполняемого файла и параметры к нему
Как правило именно после этого системного вызова мы получаем нужный процесс

exit()
Завершает процесс
Освобождает память, которую использовал процесс
Закрывает дескрипторы файлов
Сообщает код возврата 

wait()
Вызывается из процесса, который сделал вызов fork()
Считывает код возврата процесса
После того, как у процесса считали код возврата процесс полностью исчезает из системы


********************** PID, PPID ******************************
PID - уникальный номер процесса в ОС
В ОС Linux PID хранится в переменной типа (int целочисленная)
По умолчанию максимальное значение 32768

PPID - уникальный номер (идентификатор) процесса родителя
Каждый процесс имеет PID и PPID
Исключение - процессы init (PID 1, PPID 0) и kthreadd (PID 2, PPID 0)
init - самый первый процесс, запуск со стартом системы

Процесс зомби zombi - всего лишь строчка, не процесс
Плохо когда начинают плодится процессы зомби
В многопользовательской системе можно ограничитьь пользователю количество процессов, например 100
Показывает, что:
Система высоко нагружена - время между системными вызовами exit() и wait() достаточно что бы процесс зомби мог отражатся в выводе утилиты top
Есть процесс который не следит за своими потомками - от него создаются новые процессы, но при завершении работы пользователей процесс родитель не посылает запрос для выхода, их код возврата никто не считывает. А код возврата может считать только процесс родитель! Необходимо найти данный процесс родитель

Процесс сирота - процесс который остался без родителя
За процессами сиротами следит ядро и оно не дает этим процессам долго существовать
Передает его процессу init()

Как убить процесс зомби:
1. сделать этот процесс сиротой
2. его заберет процесс init()
3. считает код возврата

******************** Владелец процесса *******************
Каталог /proc/<pid> содержит все процессы
В Linux все процессы ведны всем
Управлять процессом может только root и владелец процесса

Владелец процесса:
Пользователь, от имени которого был запущен процесс
Сменить владельца процесса в Linux невозможно
Владелец процесса - владелец каталога /proc/<pid> (так можно узнать владельца процесса)

****************** Демон Daemon *************************
программа в системах UNIX, которая запускается самой системой и работающая в фоновом режиме без прямого взаимодействия с пользователем
Демон:
Процесс, который не имеет управляющего терминала 
С демоном нельзя взаимодействовать с помощью комбинаций клавиш клавиатуры
Взаимодействие с демоном происходит с помощью сигналов ОС

Примеры демонов:
apache, nginx, ssh, ftp
Будут работать пока их не остановишь

d - daemon (sshd, httpd, ntpd, proftpd - символ d в конце имени означает демона)


*************************** kill ******************************
kill стандартная функция
kill -<sifnal> <PID>
Наиболее часто применяемые сигналы:
SIGINT - 2 (сигнал прерывания (Ctrl-C) с терминала)
SIGTERM - 15 (сигнал завершения, сигнал по умолчанию для уилиты kill)
SIGKILL - 9 (безусловное завершение)

Отличие сигнала 9 и 15
на 15 сигнал можно написать свой обработчик, 15 сигнал может некорректно работать (или программа будет долго завершаться - перед завершением выполнит какие-то процедуры(кэш, очиста файлов и т.д) это занимает продолжительное время
на сигнал 9 нельзя написать обработчик
Исключениядля 9 - нельзя завершить процессы которые ожидают ввода/вывода и процесс init
Но в Unix системах нет исключений на обработку сигнала 9 


*************************** top - Load Average *******************
top
изменение скорости обновления - s (далее указать количество секунд 0-5, по умолчанию 3с)

Первая строчка выводит:
top - 11:27:02 up  2:32,  1 user,  load average: 0.58, 0.83, 0.75
top - время на сервере,
up - время которое работает сервер без перезагрузки
user - количество пользователей в данный момент
load average - показатель загруженности сервера, три варианта за 1 мин, за 5 мин, за 15 мин 

load average  (количество процессов в ожидании на ожидании ресурса)
если болеше чем за 5 и больше чем за 15, то нагрузка на сервер возрастает
и меньше чем за 5 и меньше чем за 15, то нагрузка на сервер падает

нажав цифру 1 мы увидем количество ядер процессора и чем они загружены

Пример загрузки load average, но приэтом все быстро работает:
Сетевой доступ. Отвалился диск. Но скрипты отрабатываются. Система их ставитт в очередь и выростает нагрузка load average

************************** top - CPU ******************************
Вторая строчка в top
Tasks: 263 total,   3 running, 260 sleeping,   0 stopped,   0 zombie
total - количество процессов
running - процессы которые действительно что-то делают
sliping - висят в памяти компьютера и ожидают какого-то события (apache -ожидает события на 80 порт)
stopped - остановленные процессы
zombie - процессы зомбби

Третья строка top:
%Cpu(s):  5.1 us,  1.4 sy,  0.0 ni, 93.4 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st 
us - сколько процессорных ресурсов было израсходовано в пространстве пользователя (есть пространство ядра, а есть пространство пользователя)
sy - сколько было потрачено процессорного времени на работу ядра ОС. Если система сильно нагружена сетевыми запросами, работа с драйвером устройств. 
ni - сколько процессорных ресурсов было потрачено на процессы с низким приоритетом (устарело). В столбце PR показан приоритет процесса, чем ниже цифра тем выше приоритет.
id - процент простоя процессорного времени (чем выше тем больше процессорных ресурсов, при 100 процессор ничем не занят)
wa - показывает информацию сколько было потрачено процессорного времени на работы с утройствами ввода/вывода. Если wa будет расти, это сигнал о том, что система ввода/вывода не справляется с текущими потребностями - узкое место в нашей системе либо сеть, либо диск 
(обычно диск самый низко производительный)
hi - сколько процессорных ресурсов было потрачено на обработку аппаратных прерываний (обычно не растет, только если к серверу подключить какое-то устройство которое будет слать прерывания или странно работать)
si - Software interaption программные прерывания. Их рост часо возможен. Если какая-то программа часто обращается к ядру - torrent client когда начинает раздовать информацию
st - параметр для виртуальных машин. В виртуальной машине он показывает как загружена реальная аппаратная машина. Не все гипервизоры общаются с процессором так что бы этот параметр работал 


********************** ps - efl **********************************
ps - утилита выводит все процессы в системе
ps -efl
Ключи:
e - покажет все процессы в системе
f - отобразит полную информацию (full information)
l - лог 

pstree - используем для улучшения визуализации


*********************** работа в консоли. разбор процесса ****************
ls -l /proc/ | wc -l
Выведет количество всех процессов в системе, но отнимаем два, так как это строчка "Итог" и wc это тоже процесс (если выведет 131, отнимим 2, итого в системе 129 процессов)

Разбор:
ps -efl | grep vit81
# отображаем все процессы с полной информацией и фильтруем по vit81
 vit81      94890   59677  0  80   0 -  2727 -      11:54 pts/1    00:00:00 ps -efl
# PID 94890 
└─$ ls -ld /proc/59677
dr-xr-xr-x 9 vit81 vit81 0 Mar 29 10:46 /proc/59677
# владелец vit81

ls -ld /proc/* | grep vit81
# покажет все процессы владелец которых является vit81
└─$ ls -ld /proc/* | grep vit81
dr-xr-xr-x  9 vit81            vit81                          0 Mar 29 12:05 /proc/100596
dr-xr-xr-x  9 vit81            vit81                          0 Mar 29 12:05 /proc/100597
...
dr-xr-xr-x  9 vit81            vit81                          0 Mar 29 11:57 /proc/96238
и т.д.

# количество строк ( но не забываем, что wc это процесс и надо отнять grep, wc и ls. -3)
└─$ ls -ld /proc/* | grep vit81 | wc -l
79
       
Разбор ssh:
ps -efl | grep ssh                 
1 S vit81       1851    1787  0  80   0 -  2153 -      08:59 ?        00:00:00 /usr/bin/ssh-agent x-session-manager
0 S vit81     102989   59677  0  80   0 -  1586 pipe_r 12:10 pts/1    00:00:00 grep --color=auto ssh

Покажет путь и параметры запуска

Итог:
1. Какой процесс может считать код возврата процесса?
Процесс родитель

2. Что такое PID процесса?
Process identifier - идентификатор процесса

3. Как в Linux завершить процесс?
С помощью системного вызова exit()

4. Как убить процесс зомби?
Нужно убить его родителя

5. Как в Linux создать процесс?
С помощью системного вызова fork()

6. Что такое PPID процесса?
Parent process identifier - идентификатор родительского процесса

7. У процесса всегда должен бвть процесс потомок?
нет

8. У процесса всегда должен быть процесс родитель?
Да, но в Linux есть два исключения - init и kthreadd

9. Что происходт с процессами сиротами?
Они усыновляются процессом init

10. Что такое процесс зомби?
Процесс который освободил все занимаемые им ресурсы и ожидает считывания кода возврата

11. Что такое процесс сирота?
Процесс оставшийся без родителя












